"""
Name of File: travel/views.py
Brief description of the file: determines what will be displayed when each of the functions in this file are called
Inputs: None
Outputs: Displays the HTML page
"""
from django.shortcuts import render, redirect 
from .forms import RegionSelectionForm, TouristAttractionForm, GenerateScheduleForm, RecommendRestaurantsForm
from .gpt_integration import display_regions, generate_text_with_gpt, recommend_tourist_attraction, generate_schedule, recommend_restaurant
from accounts.models import UserProfile 
from django.contrib.auth.decorators import login_required
from .weather import get_weather
from .forms import WeatherForm
from datetime import timedelta, datetime
from .map import search_location
from .images import get_location_images
import re
import json

#make login required to update the user
@login_required(login_url='login')
#function to display the region selection
def select_region(request):
	#if a form submission occurs
	if request.method == 'POST':
		#get the form submission data
		form = RegionSelectionForm(request.POST)
		#if there are no errors in the form
		if form.is_valid():
			#Get user profile to be used to retrieve user info
			user_profile = UserProfile.objects.get(user=request.user)

			#get the proper appropriate personalized info from the user's account
			personalized_user_info = {
				"dietary_restrictions": user_profile.dietary_restrictions,
				"travel_style_preferences": user_profile.travel_style_preferences,
				"preferred_airlines": user_profile.preferred_airlines,
				"budget_constraints": user_profile.budget_constraints,
				"preferred_travel_dates": user_profile.preferred_travel_dates,
				"trip_duration": user_profile.trip_duration
			}

			#get all the inputs as a dictionary from the form data
			user_input = {field_name: form.cleaned_data[field_name] for field_name in RegionSelectionForm.option_list}

			#If the user did not specify another preference in the add the users default preference
			#Loop through each personalization in the personalize user info
			for key in personalized_user_info.keys():
				#If that personalization was not specificied in the current form
				if key not in user_input:
					#if the user preference has a value
					if personalized_user_info[key]:
						#add that to the current form
						user_input[key] = personalized_user_info[key]

			#use the gpt function and display regions function to make a prompt from user_input and generate a response
			gpt_result = generate_text_with_gpt(display_regions(user_input))

			#get each line of the result as a separate line to format it better
			gpt_results = gpt_result.split("\n")

			#The regex pattern to get the travel region from the GPT output
			pattern = r'Travel Region \d+: (.+?) -'
			
			#create a list to store each result for each region
			results = []

			#loop through each line of the GPT ouptut
			for result in gpt_results:
				#If the current line is empty or is a whitespace
				if result.strip() == '':
					#skip this line
					continue
				#get the parsed result from the Regex
				parsed_result = re.search(pattern, result)

				#If the result was able to be parsed correctly
				if parsed_result:
					#Get the second group on the regex, which corresponds to the region name
					region_name = parsed_result.group(1)
					#get image urls from 3 location from that attraction
					image_urls = get_location_images(region_name, 3)
				#if there was an error parsing (likely GPT gave incorrect format)
				else:
					#say that it could not parse the output for debugging
					print("Could not parse GPT output")
					#print the output that it could not parse
					print(result)
				
				results.append({
					"gpt_result": result,
					"region_name": region_name,
					"image_urls": image_urls
				})
			
			#send back a result page that displays the result generated by GPT to the user based on their inputs
			return render(request, 'travel/region_result.html', {'results': results}) 
	#if the user has not submit the form
	else:
		#load the forms page for region selection
		form = RegionSelectionForm()
	#send to the user the select_region.html to be display on the browser, along with the proper forms for it
	return render(request, 'travel/select_region.html', {'form': form})

#make login required to update the user
@login_required(login_url='login')
#function to recommend attractions
def recommend_attractions(request):
	#if a form submission occurs
	if request.method == 'POST':
		#get the form submission data
		form = TouristAttractionForm(request.POST)
		#if there are no errors in the form
		if form.is_valid():
			#Get user profile to be used to retrieve user info
			user_profile = UserProfile.objects.get(user=request.user)

			#get the proper appropriate personalized info from the user's account
			personalized_user_info = {
				"dietary_restrictions": user_profile.dietary_restrictions,
				"travel_style_preferences": user_profile.travel_style_preferences,
				"preferred_airlines": user_profile.preferred_airlines,
				"budget_constraints": user_profile.budget_constraints,
				"preferred_travel_dates": user_profile.preferred_travel_dates,
				"trip_duration": user_profile.trip_duration
			}

			#get all the inputs as a dictionary from the form data
			user_input = {field_name: form.cleaned_data[field_name] for field_name in form.fields}

			#separate the region input from the other options to be given separetly when making a prompt
			options = {key: values for key, values in user_input.items() if key != "region"}

			
			#If the user did not specify another preference in the add the users default preference
			#Loop through each personalization in the personalize user info
			for key in personalized_user_info.keys():
				#If that personalization was not specificied in the current form
				if key not in user_input:
					#if the user preference has a value
					if personalized_user_info[key]:
						#add that to the current form
						user_input[key] = personalized_user_info[key]

			#get a prompt based on the user input, and use that prompt to give it to the GPT model to get a result
			gpt_result = generate_text_with_gpt(recommend_tourist_attraction(user_input["region"], options))

			#get each line of the result as a separate line to format it better
			gpt_results = gpt_result.split("\n")

			#This is the regex pattern used to get the tourist attraction from the GPT output
			pattern = r'Tourist Attraction \d+: (.+?) -'

			#load up credentials file that has api keys
			with open("credentials.json") as f:
				#get credentials from json
				credentials = json.load(f)

			#google maps api key
			google_maps_api_key = credentials["google_maps_api"]

			#create a list to store each result for each attraction
			results = []
			#loop through each of the gpt results
			for result in gpt_results:
				#if the gpt result is empty or is whitespace
				if result.strip() == '':
					#skip this result
					continue
				#Try to parse the tourist attraction using the regex pattern
				parsed_result = re.search(pattern, result)

				#If the attraction was correctly parsed
				if parsed_result:
					#get the second group of the parsed results which will be the attraction name
					attraction_name = parsed_result.group(1)
					#get the name, address, latitude, and logintude from the google maps API of the attraction
					name, address, lat, lng = search_location(google_maps_api_key, attraction_name)
					#get image urls from 3 location from that attraction
					image_urls = get_location_images(name, 3)
					#Add the current GPT result, name, address, latitude, and logitude to the results to display it
					results.append({
						"gpt_result": result,
						'map_data': {
							'name': name,
							'address': address,
							'lat': lat,
							'lng': lng,
						},
						"image_urls": image_urls
					})
				#if the GPT output was not able to be parsed
				else:
					#Print that it could not be parsed the result that it gave for debugging
					print("Could not parse GPT output")
					print(result)
				
			# Pass the obtained data to the template
			context = {
				'results': results,
				'api_key': google_maps_api_key,
			}

			#send back a result page that displays the result generated by GPT to the user based on their inputs
			return render(request, 'travel/attractions_result.html', context) 
	#if the user has not submit the form
	else:
		#load the forms page for tourist attraction
		form = TouristAttractionForm()

	#send to the user the recommend_tourist_attractions.html to be display on the browser, along with the proper forms for it
	return render(request, 'travel/recommend_tourist_attractions.html', {'form': form})

#make login required to update the user
@login_required(login_url='login')
#function to make schedule
def make_schedule(request):
	#if a form submission occurs
	if request.method == 'POST':
		#get the form submission data
		form = GenerateScheduleForm(request.POST)
		#if there are no errors in the form
		if form.is_valid():
			#Get user profile to be used to retrieve user info
			user_profile = UserProfile.objects.get(user=request.user)

			#get the proper appropriate personalized info from the user's account
			personalized_user_info = {
				"dietary_restrictions": user_profile.dietary_restrictions,
				"travel_style_preferences": user_profile.travel_style_preferences,
				"preferred_airlines": user_profile.preferred_airlines,
				"budget_constraints": user_profile.budget_constraints,
				"preferred_travel_dates": user_profile.preferred_travel_dates,
				"trip_duration": user_profile.trip_duration
			}

			#get all the inputs as a dictionary from the form data
			user_input = {field_name: form.cleaned_data[field_name] for field_name in form.fields}

			#If the user did not specify another preference in the add the users default preference
			#Loop through each personalization in the personalize user info
			for key in personalized_user_info.keys():
				#If that personalization was not specificied in the current form
				if key not in user_input:
					#if the user preference has a value
					if personalized_user_info[key]:
						#add that to the current form
						user_input[key] = personalized_user_info[key]

			#separate the region and attractions input from the other options to be given separetly when making a prompt
			options = {key: values for key, values in user_input.items() if key != "region" and key != "attractions"}

			#make attractions option be a list for the generate_schedule function
			attractions = user_input["attractions"].split(", ")

			#get a prompt based on the user input, and use that prompt to give it to the GPT model to get a result
			result = generate_text_with_gpt(generate_schedule(user_input["region"], attractions, options))

			#get each line of the result as a separate line to format it better
			results = result.split("\n")

			#send back a result page that displays the result generated by GPT to the user based on their inputs
			return render(request, 'travel/schedule_result.html', {'results': results}) 
	#if the user has not submit the form
	else:
		#load the forms page for generating a schedule
		form = GenerateScheduleForm()

	#send to the user the generate_schedule.html to be display on the browser, along with the proper forms for it
	return render(request, 'travel/generate_schedule.html', {'form': form})

#make login required to update the user
@login_required(login_url='login')
#function to make schedule
def recommend_restaurants(request):
	#if a form submission occurs
	if request.method == 'POST':
		#get the form submission data
		form = RecommendRestaurantsForm(request.POST)
		#if there are no errors in the form
		if form.is_valid():
			#Get user profile to be used to retrieve user info
			user_profile = UserProfile.objects.get(user=request.user)

			#get the proper appropriate personalized info from the user's account
			personalized_user_info = {
				"dietary_restrictions": user_profile.dietary_restrictions,
				"travel_style_preferences": user_profile.travel_style_preferences,
				"budget_constraints": user_profile.budget_constraints,
				"preferred_travel_dates": user_profile.preferred_travel_dates,
				"trip_duration": user_profile.trip_duration
			}

			#get all the inputs as a dictionary from the form data
			user_input = {field_name: form.cleaned_data[field_name] for field_name in form.fields}

			#If the user did not specify another preference in the add the users default preference
			#Loop through each personalization in the personalize user info
			for key in personalized_user_info.keys():
				#If that personalization was not specificied in the current form
				if key not in user_input:
					#if the user preference has a value
					if personalized_user_info[key]:
						#add that to the current form
						user_input[key] = personalized_user_info[key]

			#separate the region input from the other options to be given separetly when making a prompt
			options = {key: values for key, values in user_input.items() if key != "region"}

			#get a prompt based on the user input, and use that prompt to give it to the GPT model to get a result
			gpt_result = generate_text_with_gpt(recommend_restaurant(user_input["region"], options))

			#get each line of the result as a separate line to format it better
			gpt_results = gpt_result.split("\n")

			#This is the regex pattern used to get the tourist restaurant from the GPT output
			pattern = r'Restaurant \d+: (.+?) -'

			#load up credentials file that has api keys
			with open("credentials.json") as f:
				#get credentials from json
				credentials = json.load(f)

			#google maps api key
			google_maps_api_key = credentials["google_maps_api"]

			#create a list to store each result for each restaurant
			results = []
			#loop through each of the gpt results
			for result in gpt_results:
				#if the gpt result is empty or is whitespace
				if result.strip() == '':
					#skip this result
					continue
				#Try to parse the tourist restaurant using the regex pattern
				parsed_result = re.search(pattern, result)

				#If the restaurant was correctly parsed
				if parsed_result:
					#get the second group of the parsed results which will be the restaurant name
					restaurant_name = parsed_result.group(1)
					#get the name, address, latitude, and logintude from the google maps API of the restaurant
					name, address, lat, lng = search_location(google_maps_api_key, restaurant_name)
					#Add the current GPT result, name, address, latitude, and logitude to the results to display it
					results.append({
						"gpt_result": result,
						'map_data': {
							'name': name,
							'address': address,
							'lat': lat,
							'lng': lng,
						},
					})
				#if the GPT output was not able to be parsed
				else:
					#Print that it could not be parsed the result that it gave for debugging
					print("Could not parse GPT output")
					print(result)
				
			# Pass the obtained data to the template
			context = {
				'results': results,
				'api_key': google_maps_api_key,
			}

			#send back a result page that displays the result generated by GPT to the user based on their inputs
			return render(request, 'travel/restaurants_result.html', context) 
	#if the user has not submit the form
	else:
		#load the forms page for generating a schedule
		form = RecommendRestaurantsForm()

	#send to the user the generate_schedule.html to be display on the browser, along with the proper forms for it
	return render(request, 'travel/recommend_restaurants.html', {'form': form})

#this allows for feedback and ratings submissions in the results page
def feedback_view(request):
	#if the user clicks submit
    if request.method == 'POST':
		#this gets the user's feedback
        feedback = request.POST.get('feedback')
		
		#this keeps them in the result page so they do not get redirected to another page
        return redirect('result')

def weather_forecast(request):
    weather_data = None

    if request.method == 'POST':
        form = WeatherForm(request.POST)

        if form.is_valid():
            region = form.cleaned_data['region']
            start_date = form.cleaned_data['start_date']
            end_date = form.cleaned_data['end_date']
            unit = form.cleaned_data['unit']
            weather_data = get_weather(region, start_date, end_date, unit)

    else:
        form = WeatherForm()

    return render(request, 'travel/weather_forecast.html', {'form': form, 'weather_data': weather_data})
